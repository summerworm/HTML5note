


ken thompson

Ken和Dennis是Unix和C的发明人











·


 ****
资源
https://github.com/wonderfo/wonderfogo/wiki





LiteIDE项目：
操作系统: Windows / Linux x86 / Linux x86_64 / MacOS X 10.6
项目主页: http://code.google.com/p/golangide
项目源码 : http://code.google.com/p/liteide
讨论组: http://groups.google.com/group/liteide-dev
下载链接: http://code.google.com/p/golangide/downloads/list





Go 语言中文翻译项目
http://code.google.com/p/golang-china/

Go语言文档
https://golang-china.googlecode.com/svn/trunk/Chinese/golang.org/index.html



在Google App Engine支持部署 Go语言。







Go语言中文小组

Go语言官方网站：http://golang.org/
Godoc本地化翻译: http://code.google.com/p/go-zh/
Go语言中文论坛：http://bbs.golang-china.org/
Go语言中文Wiki：http://wiki.golang-china.org/
Go语言中文官网：http://golang-china.org/
Go语言中文IRC: irc.freenode.net #golang-china
Go语言视频(优酷)：http://u.youku.com/golangchina
中文文档版本库(SVN)：http://code.google.com/p/golang-china/
GitHub与本站SVN同步(GIT)：http://github.com/border/golang-china
其他资源：QQ群(102319854) QQ群2(29994666)；中文小组邮件列表 ；GolangChina@Twitter
Go Programming Language Resources
Chrome插件： The Go Playground

开源项目
Go Web框架Golanger Golanger Web Framework










Go 的文件与目录遍历方法 － path/filepath.Walk
http://cox.im/articles/go-walk-files-diretories.html


睡眠排序算法-go语言版
http://www.sharejs.com/codes/go/6498




sublime
liteide




《三天学会Go语言》的教程，包括三部分：基本结构，面向对象，并发。

Go语言的面向对象
     Go语言在C语言语法的基础上，以最简洁的形式加入了面向对象。
    关于继承：Go语言没有继承。但是它支持嵌入，这个有点类似于其它语言的mixin，可以用来模拟继承。
    关于多态：Go 语言的最大特点是它的接口定义。所谓“接口”，就是一组方法的集合。任何一个类只要实现了一个接口的所有方法，则是该接口的实现者，不需要显式声明实现该接口。所以一个没有任何方法的空接口可以代表任何类型。

Go语言的并发
     Go语言提出一个新的概念—Go例程，有点类似于线程，但是更加轻量，更省资源。Go例程之间的通信方式 ——信道，这是GO 语言的核心概念，有点类似于UNIX的Pipe。在Go语言中，不需要接触线程，锁这些低阶概念。

Go语言可以用来做什么
     Go语言目前最强的是它的网络功能。它的package中已经实现了最常见的网络协议和编码处理。Go的官方网站使用的就是Go语言，实际上它就是Go的文档系统godoc。
      还没有官方对数据库支持，不过因为通过某种办法可以在Go语言中直接调用C函数，所以很容易的实现对MYSQL 或者 Sqlite 这些数据库的支持。
      至于GUI，这估计目前还不在设计者的考虑范围之内，因为他们连Windows都不舍得支持。不过可以通过它的http包和template包等等，已经构成了一个WEB框架，可以用来实现WEB GUI的开发，使用Go写一个带有路径分派的Http服务器也就几行代码的事。


mixin可能造成的问题有：子类指针不能转成父类指针。如果真的不能，那继承是没意义的。

是的，毕竟Go没有继承，没有虚函数，它没有子类和父类的概念，所有的指针都视为不同的类型。但是，对于Go语言来说，接口不是指针，这是它和其它语言的不同。如果要多态，就应该使用接口，而不是具体的类。

面向对象的两条重要原则：1.面向接口编程，而不是面向实现编程 2 优先使用组合而不是继承， 这在别的语言中只不过是口头约定，而在Go语言中，你则不得不这样做。

关于为什么没有继承，官方FAQ是这么说的：它简化了类之间的关系，不再有复杂的类型体系。接口的隐式风格，使一个类型不需要提前声明，就可以一次满足多个接口，同时又没有传统的多重继承的复杂性——“这种风格需要一段时间来适应，但这是Go语言最令人激动的事情之一”。

说到开发效率, 在服务器领域，Go绝对优于Java，C++，就不用提了。

以平坦的方式编写函数，没有层次。而后用 interface 把需要的功能聚合在一起。没有继承层次，只有组合功能。

go 在语言设计上是很吝啬新的关键字的。但多出一个关键字 defer ，并用内建函数 panic / recover 来解决许多看似应该用 exception 解决的问题要漂亮的多。




如果要真正的用好Go语言，理解它的语言特性和设计思想是 很重要的。

最后拼的还是操作系统，数据结构，算法。



faq  
http://code.google.com/p/golang-china/wiki/go_programming_faq





这里我以tour.golang.org中的一个练习为例子

http://tour.golang.org/#70




http://blog.golang.org/

内存模型
http://code.google.com/p/golang-china/wiki/go_mem

针对C++程序员指南
http://code.google.com/p/golang-china/wiki/go_for_cpp_programmers
 FAQ
http://code.google.com/p/golang-china/wiki/go_programming_faq


http://golang.org/doc/codelab/wiki

Defer, Panic, and Recover
http://golang-china.googlecode.com/svn-history/r177/trunk/Chinese/golang.org/defer_panic_recover.html



http://blog.golang.org/




godoc
https://github.com/astaxie/godoc


-------------------------------
推荐学习【阅读】两个Go语言项目源码 
目前Go语言比较好的，线上运行的个人项目，都是国内的人写的

https://github.com/QLeelulu/ohlala
对应的网站：http://milnk.com

https://github.com/jimmykuu/gopher
对应的网站:http://golang.tc
-------------------------------


加密解密之DES：Go语言、Java语言和PHP语言
http://blog.studygolang.com/167.html


Go语言开发的神经网络库：GoNN
http://www.open-open.com/lib/view/open1351780288342.html


Go语言的Web开发框架 Web.Go
http://www.open-open.com/lib/view/open1323762663531.html





google 开发
https://developers.google.com/appengine/docs/go/gettingstarted/helloworld?hl=zh-CN





《Go Web编程》《build web application with golang》
https://github.com/astaxie/build-web-application-with-golang


Go 语言文档.doc
http://www.open-open.com/doc/view/72928010dd424fe2bd3605b1fd5a7cd6




 ****
Go 语言网络编程.pdf
http://www.open-open.com/doc/view/23b01993ee2d4ea1b51ca4fe3e753d5c





编写Web程序
https://golang-china.googlecode.com/svn/trunk/Chinese/golang.org/index.html#toc87


code.google.com/p/ac-me


学习 Go 语言.pdf
http://www.open-open.com/doc/view/6170d723a86a4e49bbd1f29bc94715d1
http://www.open-open.com/doc/view/a1075d5d4c5e472d8367e2febb457e69
http://www.open-open.com/doc/view/3aeb11c3b62442c4a69a1115c433088a
121
http://www.open-open.com/doc/view/cf401b09081b4d7bae0f5cdc9723a996

 ****
Google Go 语言教程(够粉丝).pdf
http://www.open-open.com/doc/view/cf6adcc102b845ffa4449c5baeccaeed

Go 语言的持久层框架：gorp
http://www.open-open.com/lib/view/open1346943904537.html


Go语言绘制饼图和柱状图 ajstarks-chart
http://www.open-open.com/lib/view/open1346250610879.html

Go读取xlsx文件的库 XLSX
http://www.open-open.com/lib/view/open1341878702541.html


搜索引擎Sphinx的Go开发包 GoSphinx
http://www.open-open.com/lib/view/open1341878672072.html

STOMP 客户端包 stompngo
http://www.open-open.com/lib/view/open1341845680947.html

MySQL的Go驱动 GoMySQL
http://www.open-open.com/lib/view/open1341845639447.html

Go语言的2D游戏开发包 Go2D
http://www.open-open.com/lib/view/open1341845559447.html

Go 语言开发的宠物小精灵游戏 - Pokemon Universe
http://www.open-open.com/lib/view/open1341845526354.html

Go 语言版的 OpenCV 封装 - GoOpenCV
http://www.open-open.com/lib/view/open1341845443166.html

Go-HTTP-JSON-RPC
Go-HTTP-JSON-RPC 是用来处理 HTTP JSON-RPC 的 Go 语言实现。
http://www.open-open.com/lib/view/open1341845352869.html

使用Go解析超大XML文档
http://www.open-open.com/lib/view/open1340583480342.html

Go语言的RESTful框架 goweb
http://www.open-open.com/lib/view/open1333976869889.html





Go 中文社区 
Go官方网站 http://golang.org/ 
Go中文官网 http://golang-china.org/ 
中文论坛(测试中…) http://bbs.golang-china.org/ 
中文用户讨论组(邮件) https://groups.google.com/group/golang-china/ 
中文翻译(SVN) http://code.google.com/p/golang-china/ 
GitHub与Google Code同步(GIT) http://github.com/border/golang-china 


 ***
Effective Go 
http://code.google.com/p/golang-china/wiki/effective_go



go 工具
http://www.mikespook.com/2012/02/%E7%BF%BB%E8%AF%91go-%E5%B7%A5%E5%85%B7/


Go Bindings for Various External APIs
http://go-lang.cat-v.org/library-bindings

Go语言标准库概览
http://tonybai.com/2012/09/08/a-brief-tour-of-go-standard-library/


博客
http://www.tuicool.com/topics/11080084


 ****
http://www.congci.com/tag/golang

 ****
Golang Web服务器开发
http://www.congci.com/item/golang-web-server-dev-dajian






go语言的list
http://www.oschina.net/code/snippet_126593_16685





golang实现rpc远程调用的server端和client端范例
http://www.sharejs.com/codes/go/5659

go语言接口简单范例
http://www.sharejs.com/codes/go/5657












·看过的


 ****
胡文 Go.ogle.pdf 2010.11.16
http://www.open-open.com/doc/view/03c212177a364579a67194f60059534c


看了一半
Go语言WEB开发.pdf
http://www.open-open.com/doc/view/d4258fc14d8d4622a092d89106b40121












·App Engine


 ****
Go  + App Engine  =
Johan Euphrosine 
2012年3月15日
http://progginator.lidian.info/#1



App Engine 允许用户在 Google 的基础设施之上构建自己的 web 应用

Go Runtime
原生代码
低内存消耗
并行设计


Hello proggit! （JSON 解析）
http://progginator.lidian.info/#13

并行处理
http://progginator.lidian.info/#20




·go《Go Web编程》

 ****
目录
https://github.com/astaxie/build-web-application-with-golang
https://github.com/astaxie/build-web-application-with-golang/blob/master/preface.md





8.2 WebSocket
https://github.com/astaxie/build-web-application-with-golang/blob/master/08.2.md

https://github.com/astaxie/build-web-application-with-golang/blob/master/preface.md

2.4 struct类型
https://github.com/astaxie/build-web-application-with-golang/blob/master/02.4.md
2.5 面向对象
https://github.com/astaxie/build-web-application-with-golang/blob/master/02.5.md
2.6 interface
https://github.com/astaxie/build-web-application-with-golang/blob/master/02.6.md
2.7 并发
https://github.com/astaxie/build-web-application-with-golang/blob/master/02.7.md
2.8 总结
https://github.com/astaxie/build-web-application-with-golang/blob/master/02.8.md







Web基础

浏览器，发送 HTTP Request（请求）
服务器，返回 HTTP Response（响应）

客户机与服务器之间的通信是非持久连接的


所谓 递归查询过程 就是 “查询的递交者” 更替, 而 迭代查询过程 则是 “查询的递交者”不变。

在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。

HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， Web程序引入了Cookie机制来维护连接的可持续状态。


HTTP请求包

我们先来看看Request包的结构, Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。header和body之间有个空行

GET /domains/example/ HTTP/1.1      //请求行: 请求方法 请求URI HTTP协议/协议版本
Host：www.iana.org             //服务端的主机名
User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4            //浏览器信息
Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8    //客户端能接收的mine
Accept-Encoding：gzip,deflate,sdch     //是否支持流压缩
Accept-Charset：UTF-8,*;q=0.5      //客户端字符编码集
//空行,用于分割请求头和消息体
//消息体,请求资源参数,例如POST传递的参数


GET	GET请求消息体为空	一般用于获取/查询
POST	POST请求带有消息体	一般用于更新

HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE
								查，改，增，删

GET和POST的区别 
1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中. 
2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. 
3. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。


HTTP响应包

HTTP/1.1 200 OK                     //状态行
Server: nginx/1.0.8                 //服务器使用的WEB软件名及版本
Date:Date: Tue, 30 Oct 2012 04:14:25 GMT        //发送时间
Content-Type: text/html             //服务器发送信息的类型
Transfer-Encoding: chunked          //表示发送HTTP包是分段发的
Connection: keep-alive              //保持连接状态
Content-Length: 90                  //主体内容长度
//空行 用来分割消息头和主体
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"... //消息体

Response包中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。

状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别

1XX 提示信息 - 表示请求已被成功接收，继续处理
2XX 成功 - 表示请求已被成功接收，理解，接受
3XX 重定向 - 要完成请求必须进行更进一步的处理
4XX 客户端错误 - 请求有语法错误或请求无法实现
5XX 服务器端错误 - 服务器未能实现合法的请求

200是常用的，表示正常信息，302表示跳转。


HTTP协议是无状态的和Connection: keep-alive的区别

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。

从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。

Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间

网页优化方面有一项措施是减少HTTP请求次数，就是把尽量多的css和js资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。



对web的路由，静态文件，模版，cookie等数据进行设置和操作。


web工作方式的几个概念
Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息
Response：服务器需要反馈给客户端的信息
Conn：用户的每次请求链接
Handler：处理请求和生成返回信息的处理逻辑


http包执行流程
1.创建Listen Socket, 监听指定的端口, 等待客户端请求到来。
2.Listen Socket接受客户端的请求, 得到Client Socket, 接下来通过Client Socket与客户端通信。
3.处理客户端的请求, 首先从Client Socket读取HTTP请求的协议头, 如果是POST方法, 还可能要读取客户端提交的数据, 然后交给相应的handler处理请求, handler处理完毕准备好客户端需要的数据, 通过Client Socket写给客户端。

这整个的过程里面我们只要了解清楚下面三个问题，也就知道Go是如何让Web运行起来了
如何监听端口？
如何接收客户端请求？
如何分配handler？


Go的http有两个核心功能：Conn、ServeMux

客户端的每次请求都会创建一个Conn，这个Conn里面保存了该次请求的信息，然后再传递到对应的handler，该handler中便可以读取到相应的header信息，这样保证了每个请求的独立性。


获取请求方法是通过r.Method来完成的，这是个字符串类型的变量，返回GET, POST, PUT等method信息。

默认情况下，Handler里面是不会自动解析form的，必须显式的调用r.ParseForm()后，你才能对这个表单数据进行操作。
r.Form里面包含了所有请求的参数，比如URL中query-string、POST的数据、PUT的数据，所有当你在URL的query-string字段和POST冲突时，会保存成一个slice，里面存储了多个值，Go官方文档中说在接下来的版本里面将会把POST、GET这些数据分离开来。

服务器端打印接受到的信息 request.Form 是一个 url.Values 类型，里面存储的是对应的类似 key=value 的信息，下面展示了可以对form数据进行的一些操作:
v := url.Values{}
v.Set("name", "Ava")
v.Add("friend", "Jess")
v.Add("friend", "Sarah")
v.Add("friend", "Zoe")
// v.Encode() == "name=Ava&friend=Jess&friend=Sarah&friend=Zoe"
fmt.Println(v.Get("name"))
fmt.Println(v.Get("friend"))
fmt.Println(v["friend"])

Request本身也提供了FormValue()函数来获取用户提交的参数。如r.Form["username"]也可写成r.FormValue("username")。调用r.FormValue时会自动调用r.ParseForm，所以不必提前调用。r.FormValue只会返回同名参数中的第一个，若参数不存在则返回空字符串。

在页面端的js验证(目前在这方面有很多的插件库，比如ValidationJS插件)

r.Form对不同类型的表单元素的留空有不同的处理， 对于空文本框、空文本区域以及文件上传，元素的值为空值,而如果是未选中的复选框和单选按钮，则根本不会在r.Form中产生相应条目，如果我们用上面例子中的方式去获取数据时程序就会报错。所以我们需要通过r.Form.Get()来获取值，因为如果字段不存在，通过该方式获取的是空值。但是通过r.Form.Get()只能获取单个的值，如果是map的值，必须通过上面的方式来获取。

使用正则表达式的速度会比较慢
Go实现的正则是RE2，所有的字符都是UTF-8编码的。

对于中文我们目前有效的验证只有正则方式来验证
if m, _ := regexp.MatchString("^[\\x{4e00}-\\x{9fa5}]+$", r.Form.Get("realname")); !m {
    return false
}

https://github.com/astaxie/build-web-application-with-golang/blob/master/04.2.md
英文
电子邮件地址
手机号码
下拉菜单
单选按钮
复选框
日期和时间
身份证号码


操作slice和map的库)，https://github.com/astaxie/beeku


要使表单能够上传文件，首先第一步就是要添加form的enctype属性，enctype属性有如下三种情况:
application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）
multipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。
text/plain    空格转换为 "+" 加号，但不对特殊字符编码。



访问数据库
Go没有内置的驱动支持任何的数据库，但是Go定义了database/sql接口，用户可以基于驱动接口开发相应数据库的驱动




其实字符串处理我们可以使用strings包来进行搜索(Contains、Index)、替换(Replace)和解析(Split、Join)等操作，但是这些都是简单的字符串操作，他们的搜索都是大小写敏感，而且固定的字符串，如果我们需要匹配可变的那种就没办法实现了，当然如果strings包能解决你的问题，那么就尽量使用它来解决。因为他们足够简单、而且性能和可读性都会比正则好。
























·go学习笔记


基本数据类型
a.不同类型，不同长度之间不允许相互转换，不能相互赋值。
c."int"和"int32"属于同一种类型，但是byte 和int8是同一种类型

var x int = 1  
var x,y = 1,2  
x,y:=1,2  
a.Go编译器对声明却未使用的变量报错。可以使用_变量代替
b._为特殊的变量名，任何赋给其的值都会被抛弃。

常量
const x int = 2  
const y = 2  

枚举值
可使用itoa来代表，每次使用从0加1
const(  
x = iota    
y = iota    
z = iota     
)  
则x,y,z分别为0,1,2。必须放在()才会递增。

4 类型转换
1）go语言不会对不同类型变量做任何隐式转换
2) 只支持少数几种类型的强制转换。

数组
var arr [10]int
arr := [10]int{1,2,3}   //创建数组并初始化部分元素
arr := [...]int{1,2,3}    //根据初始化元素个数创建数组
不想初始化所有值？使用key:value对：
  [10]int{2:1, 3:1, 5:1, 7:1}


字符串也是个数组,不过,他不能通过下标赋值,因为!他是UTF8的.


slice类型
slice是一个引用类型，是一个动态的指向数组的指针。
slice总是指向一个底层的数组array
1）创建slice
动态数组创建，类似创建数组，但是没有指定固定长度
var al []int                      //创建slice
sl := make([]int,10)    //创建有10个元素的slice
sl:=[]int{1,2,3}             //创建有初始化元素的slice


2) 先创建数组,在数组的基础上建立切片slice
var arr =[10]{1,2,3}  
sl := arr[2:5] //创建有3个元素的slice

3)数组和slice的区别
a.声明数组时，方括号内写明了数组的长度或者...,声明slice时候，方括号内为空
b.作为函数参数时，数组传递的是数组的副本，而slice传递的是指针。

3 map类型
map是一种引用类型,一种键值对存储方式,也是动态存储的。
1）创建map
var 变量 map[键类型]值类型
var m map[string]int                       //创建map
m := make(map[string]int)            //创建map
m := map[string]int{"one":1, "two":2, "three":3 }    //创建有初始化元素的map

4 数组，slice，map的操作
下面几个是golang预定义的内建函数，无需导包就可以使用。
1)  数组，slice，map的长度或元素个数。
len(sl)  获取元素个数
cap(sl) 获取最大容量

2) slice的添加复制
append(目标sl,...元素) 添加一个或多个元素，返回一个slice（容量不够时，可能会改变指针指向的对象）。
copy(目标sl1, 源sl2[m:n]) 复制元素为源sl2的m-n位置。复制到目标sl1的0-len位置。 

3）map赋值,删除和检验
m["one"]=1                   //map元素赋值
delete m["one"]          //删除map中元素
val,ok L= m["one"]     //检验map元素是否存在,如果存在ok为true，返回其值为val    

4）数组,slice,map循环遍历
//循环map，返回map对象的键和值
for key,val := range m{
//语句
}


make与new
1）new
new(T) 分配一个T类型的内存空间，并且指向这个对象的 *T类型的指针。（新建时内存空间会填充默认值））

2）make(S, 长度L，容量V ) 创建一个S类型的数据结构。返回一个初始化后的S类型。（make会初始化内部的数据结构，填充适当的值）
比如slice,首先创建一个数组长度为 "[容量V]" 的S数组（初始化时填充默认值），然后建立一个slice片段的数据结构（指向数组前"长度L"个元素)。

3）new和make区别
 new(T) 可以用来创建普通类型，返回一个指向初始化T值的指针。
make(S) 只能用来创建slice，map，channel。返回一个初始化的S值。（感觉S本身就接近一个指针类型了）


if

if x, y := 1, 1; x == y {  
    fmt.Println("true")  
} else {  
    fmt.Println("false")  
}  
1）if语句的条件没有括号()，"{"必须紧接条件在同一行。
2）if，switch语句中可包含一个初始化语句(也可以没有)，通常用于设置局部变量值


for

1）for循环
for 初始化语句，判断条件，步长 {
执行语句
}

2)类似while的for循环
for 判断条件 {
执行语句
}

3）死循环
for{
执行语句
}


range循环
range是用来循环遍历string,数组，slice,map,channel的元素的迭代器。
1）对于string，数组，slice，range返回元素位置和元素值。
2）对于map，range返回元素的key值和value值。


switch分支语句
switch表达式值不需要是常量或整数
switch没有表达式自动匹配表达式为true
switch 表达式{
case 值: 执行语句 
fallthrough
default: 执行语句
}
1)其他语言满足一个case条件，下面的case也会继续执行，除非使用break。
2）golang当满足一个case条件，下面的case不会继续执行，除非使用fallthrough。


break和continue
1)跳出循环
break跳出本层循环的所有次循环
continue跳出本层循环的本次循环


跳出多重循环
break后面可以接标签，表示跳出多重循环
Here： for 条件{
for条件{
break Here
}
}


goto跳转语句
跳转到当前函数内的标签，类似java的break
Here:
执行语句
go Here

Goto不能跳过变量声明


Panic和Recover我们就将他们看成是其他语言中的throw和catch



函数
1）函数定义方式如下
func 函数名(参数名 参数类型))(返回值名 返回值类型){
函数语句
return 返回值
}

2）返回多个值
函数返回值可以是多个值，比如:
func sum(x int ,y int ) (s int,err error){  
    return x+y,nil  
} 
可以省略返回值名称，只保留返回类型。

3)命名返回参数
当返回参数有着变量名，return后面可以不接变量。返回值默认为返回参数变量的值。
func sum(x int, y int) (s int, err error) {  
    s = x + y  
    err = nil  
    return  
}  


4）可变参数
Go函数支持变参。最后一位参数可是有着不定数量的同类型变量的参数。比如
func sum(arg ...int)(s int,err error){  
    //执行语句  
}  
调用可变参数时，传入一个数据结构，可以调用这个数据结构的全部，或者调用这个数据结构的切片。
例如：
全部调用 myfunc2(arg...);
调用片段 myfunc2(arg[:2]...);


引用传递与值传递
1）参数为普通数据类型
go语言参数传递的是参数的副本。对于普通类型相当于参数是变量的拷贝。
在函数中的操作等对原来的变量都是没有影响的。如果要在函数中修改影响传进来的值，则必须进行取地址作为参数传递。
如果数据结构比较大的话，建议传递指针。否则传递数组参数需要复制，占用较多内存和时间。

2）参数为数据结构（数组是值传递）
Go语言中string，slice，map这三种类型的实现机制类似指针，相当于引用传递。
在函数对string，slice，map参数变量的修改都会影响原来的变量。



函数作为值
1）可以将一个函数作为值，
首先可以声明一个函数类型，根据函数类型可以创建一个函数值。
拥有相同参数和相同返回值的函数属于同一个函数类型,但是不同函数名的函数代表不同的函数值。

2）函数作为值，作为参数传递。
声明如下：
函数名可以作为一个值类型，通过参数传递。


匿名函数
定义匿名函数
func(){
执行语句
}

定义匿名函数并执行
func(){
执行语句
}()

回调函数
函数作为值时，可将函数作为一个参数传递到其他的函数里面，其他的函数里面执行这个函数参数。


包package
包是数据与函数的集合。每一个包相当于一个模块。
包可以被其他的包import引入后使用其中的类型，变量和函数。

导入包
import "包名"
import 包别名 "包名"
import _ "包名"  这儿使用`_`的意思是引入后面的包名但是不直接使用这个包中定义的函数，变量等资源。
impoert . "包名" 

新建包
使用package定义一个包，定义的时候包名和所在目录一致，但是不必和所在文件名保持一致。

当import的目录使用"/"来分割时候，表示多层目录。

包的运行
首先，会根据import语句加载其他包。
其次，会根据const语句来创建常量。
再次，会根据var语句来创建变量。
最后，会根据init函数执行初始化。
当上面一切就绪后，运行main,main()函数，执行程序。

包的修饰
1）首字母大写：所有的变量，如类型，全局变量，共有函数等首字母大写时是可导出的，在包外可调用。
2）首字母小写：所有的变量，如类型，全局变量，私有函数等函数名首字母小写。不可导出的，只在包内部调用。

4 常用的包
fmt 格式化的IO输出 常用方法：Print() Println() Printf() Scanf()
io 原始的IO操作
bufio 实现缓冲的IO操作
sort 对数组和集合的排序
strconv 字符串和基本数据类型间的转换
os 操作系统接口包
sync 同步包
flag 命令行解析
templete 数据模板
http HTTP服务实现包
reflect 反射包
exec 执行外部命令包


类型type
type 新类型 原有类型 
新类型只继承原类型的字段，但是不会继承原类型的方法。
type integer int

建立一个数据结构的新类型
type 新类型 struct{
变量名称 变量类型
变量名称 变量类型
}
type Animal struct{  
    name string  
    age int   
}  
赋值初始化（变量类型为Animal）       
var pig Animal   // 创建一个Animal 
pig.age = 5   // 变量ani的age属性赋值25

键值方式初始化（变量类型为Animal）  
pig := Animal  {age:5, name:"pig"}
pig := Animal  {"pig", 5}         //省略字段名称，属性按顺序自动赋值

new方式初始化（变量类型为*Animal）
pig := new(Animal) 


可以为一个类型添加方法：
func (变量名 类型) 方法名(参数变量 参数类型) 返回变量 返回类型
func (变量名 *类型) 方法名(参数变量 参数类型) 返回变量 返回类型

func (ani Animal) GetAge() int{  
    return ani.age  
}  
func (ani *Animal) GetAge2() int{  
    return ani.age  
}  

当调用一个Animal类型的变量的方法时，首先会查找这个"变量"的方法列表,查找ani.GetAge()。没有则查找 "&变量"的方法列表,查找(&ani).GetAge()。
当调用一个*Animal类型的指针的方法时，首先会查找这个"变量"的方法列表,查找ani.GetAge()。没有则查找 "*变量"的方法列表,查找(*变量).GetAge()。


继承
go语言实现继承的方法更类似于组合方式。
如果一个类型包含一个作为其属性的类型，那么其可以调用这个属性类型中的属性和方法。

比如定义一个类型Animal，如果需要定义一个Dog类型继承Animal的方式。可使用如下方式实现。
创建Dog类型，并且包含Animal类型匿名字段。这样Dog变量就可以调用Animal中的属性和方法了。

type Animal struct {  
    Name string  
    Age  int  
}  
  
func (ani *Animal) GetAge() int {  
    return ani.Age  
}  
  
type Dog struct {  
    Animal //Animal匿名字段  
}  
  
func main() {  
    dog := Dog{Animal{"dog", 10}}  
    fmt.Println(dog.Age)  
    fmt.Println(dog.GetAge())  
}  

方法重写
type Dog struct {  
    Animal //Animal匿名字段  
}  
  
func (ani Dog) GetAge() int {  
    return ani.Age + 1  
}  

Go使用组合来实现继承和重写:
首先一个B类型包含A类型。所以当变量b调用一个方法，属性等，首先检查B中是否有此属性或方法。如果有调用b.f()。
如果属性或方法不存在。则去调用其属性类型中的属性或方法b.a.f()。


接口
定义接口，接口中可以有未实现的方法。
type Animal interface {  
    GetAge() int  
}  

实现接口类型
如果某个类型实现了接口的所有方法。则这个类型实现了这个接口。

空接口
空接口interface{}，是一个不包含任何方法的类型，所有类型都实现了interface{}类型。
当参数类型是一个interface{}类型时，可以传递任何类型的值。interface{}类似于java中的Object类型。

接口继承
如果一个接口类型包含另一个接口类型的属性。则此接口包含另一个接口的方法。


type Speaker interface {
    Say()
}
上面定义了一个接口，只有一个方法，Say，不需要参数，也没有返回值。Go里面，任何拥有某个接口所定义所有方法的东西，都默认实现了该接口。这是一句拥有太多内涵的话，足矣对设计思路产生重大的影响。比如下面这个方法，它接受一个类型为Speaker的参数。

func SaySomething(s Speaker) {
    s.Say()
}

那么所有拥有Say()方法的东西都可以往里扔。

在Go的世界里，所有的东西都默认实现了interface{}这个接口。有了这个概念，即使没有泛型也能有效的降低设计复杂度。


管道
channel
ch := make(chan int) //创建一个只能传递整型的管道

func pump(ch chan int) { 
    for i := 0; ; i++ { ch <- i } //往管道里写值 
}

func suck(ch chan int) { 
    for { fmt.Println(<-ch) } //这里会等着直到有值从管道里面出来 
}

go pump(ch) //异步执行pump

go suck(ch) //异步执行suck

嘿嘿，然后你就看到控制台上输出了一堆数字。










正如大多数参与Go语言项目的新手程序员痛斥的，在异常处理时最麻烦


“好奇号”火星车上安装有两个完全一样的计算机。我们注意到美国宇航局正是按照Joe Armstrong(Erlang编程语言的创造人)的话做的：“要想获得一个可信赖的系统，你需要两台计算机”。一个一直处于休眠状态，一旦另一个由于异常情况死机，它可以随时受命接管系统。

这样的做法在Erlang语言系统里、在OpenBSD PF防火墙等其它软件里都是很典型的接管方案。


注入
热修复

Erlang是软实时系统，只能达到毫秒级的实时性，不满足火星车的硬实时需求。

什么是闭包。简单说：它是一个能返回另一个函数的函数。被返回的函数里可以访问到其父函数的有效变量访问范围内的所有变量——就像是面向对象语言，例如C#或Java，里的私有内部类。


特兰斯凯是南非非常具有乡野特色的地方，到处是连绵的小山，一些小村庄和土堆的茅屋。他们仍然沿袭着酋长制度，有一个首领，大多数的当地人靠捕鱼为生。我们在高低不平的土路上颠了两天才到达我心仪的地方，一个美丽的海湾，叫做咖啡湾(Coffee Bay)。

非洲是一个让你脱离尘世的地方

非洲是一个让你脱离尘世的地方，解放你的思想，重新认识人生最重要的东西是什么。

从泰国到柬埔寨到越南是我这次旅行中做喜欢的部分，如果你从没有到过亚洲，你绝对应该去一次。这些国家非常的漂亮，气候非常的好，食物美味可口，人们非常友善。吴哥窟是世上最神奇的地方之一，每个人都应该去看看。
 ****
旅行，写作，编程
http://www.aqee.net/traveling-writing-programming/


最能干的程序员所工作的公司几乎都能给他们最大的隐私权，最大的个人空间，最大的控制他们的物理空间的自由度，最少的外界干扰。”

具有10年工作经验的程序员并不比只有2年经验的表现的优秀。

在同一个公司里面,你很难超过平均效能的2.5倍,我称之为热障.

Go语言适合于”很多程序员一起开发的大型软件，并且开发周期较长，支持云计算的网络服务：简言之，就是服务端软件。Go语言能够让程序员快速开发，并且在软件不断的增长过程中，它能让程序员更容易地进行维护和修改。它融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性。

Node.js，Fils 说，很流行，“虽然我很喜欢它，但它的单线程事件循环机制和非阻塞的编程模式让我不太满意。还有，所有的东西都要用Javascript的回调函数，我不喜欢这样。”很显然，他不是一个JavaScript的粉丝。Go语言的语法和结构，从另一方面讲，“还是很简洁的。

Go语言给人的感觉像一个动态的类型化语言，Fils说，但Go语言里静态类型特征并不像Java里那样明显。

Go语言的垃圾收集管理，比JVM要好的多。跟Groovy这样的动态语言比起来尤其能看出这点。

Fils在评论中说Go语言的速度比其它语言快很多倍。它运行速度快但不影响负载量。它编译所需的时间很短，他在开发时能边开发边编译，就像动态语言那样迅速。

最后，他说使用Go语言要比使用Node.js，Java或以Java为基础的语言，Ruby on Rails等语言要有趣的多。在开发JVM平台上的应用时，我总感觉自己是一个系统管理员，而不是一个开发者。我要修改堆空间，我要研究负载均衡或内存问题或其它的资源管理问题。而使用Go语言，我不需要考虑这些。我开发，编译，测试，运行，部署，非常的享受。



函数
func funcname(input1 type1, input2 type2) (output1 type1, output2 type2) {
        //这里是处理逻辑代码
        //返回多个值
        return value1, value2
}


变参
Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：
func myfunc(arg ...int) {}

arg ... int 告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是int。在函数体中，变量arg是一个int类型的slice：
for _, n := range arg {
        fmt.Printf("And the number is: %d\n", n)
}


传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为我们作用在了copy上面。

需要将x所在地址&x传入函数，并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改 x变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。

传指针有什么好处呢？
传指针使得多个函数能操作同一个对象。
传指针比较轻量级，只是传内存地址，我们可以通过指针高效的传递大的结构体。如果传值的话，那么每次传递, 在copy上面就会花费大量的时间和内存。所以记住了，当你要传递大的结构体的时候，用指针是一个明智的选择。
GO语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数会改变slice的长度，则仍需要取地址传递指针）


defer
回调函数
在defer 后指定的语句会在函数退出前调用。
如果有很多调用defer，那么defer是采用后进先出模式


函数作为值、类型
在Go中函数也是一种变量，我们可以通过type来定义他
他的类型就是所有拥有相同的参数，相同的返回值的一种类型
type type_name func(input1 type1, input2 type2) (output1 type1, output2 type2) 

函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递

函数当做值和类型在我们写一些通用接口的时候非常有用，


Panic和Recover

Go没有例如像Java那样的异常机制：不能抛出一个异常。作为代替，它使用了panic和recover机制。一定要记得，这应当作为最后的手段被使用，你的代码中应当没有，或者很少的令人恐慌的东西。这是个强大的工具，明智的使用它。那么，应该如何使用它。

Panic
是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执 行，然后F返回到调用它的地方。在调用的地方，F的行为就像调用了panic。这一过程继续向上，直到发生panic的goroutine中所有调用的函 数返回，此时程序退出。恐慌可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。

Recover
是一个内建的函数，可以让进入令人恐慌的流程中的goroutine恢复过来。Recover仅在延迟函数中有效。在正常的执行过程中，调用 recover会返回nil，并且没有其他任何效果。如果当前的goroutine 陷入恐慌，调用recover可以捕获到panic的输入值，并且恢复正常的执行。


main函数和init函数

Go里面有两个保留的函数：init函数(能够应用于所有的package)和main函数(只能应用于package main)。这两个函数定义的时候必须都是没有任何参数，也没有任何返回值的。虽然一个package里面可以随便写多个init函数，但是对于易读性还 是以后的维护性来说，我们还是强烈建议用户一个package只写一个init函数。

Go程序里面会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。

init函数每个package里面是可选的
init函数
go程序在导入每个package时候，首先会自动执行这个package的init函数。init函数主要用来做一些数据初始化。


初始化和执行程序都是开始于main包，如果有import其他包，那么依次import进来。虽然有很多个包里面import了同一个包，但是这 个包只会import一次

当一个 package被import进来的时候，如果他本身还import了其他包，那么先执行import其他包，然后执行这个包里面的包级别的常量和变量， 然后执行init函数(如果包里面有的话)。最后所有的被main包import的包都加载完毕了，然后开始执行main包里面的常量和变量的初始化，然 后执行main包里面的init函数(如果存在的话)，最后执行到了main函数。 


Go编译器对声明却未使用的变量报错。可以使用_变量代替
_为特殊的变量名，任何赋给其的值都会被抛弃。


var i = complex(1,2);
i是一个复数,可以通过函数(目前可以不理解)imag和real取出虚部和实部

float比较大小要小心哦,0.1+0.2可能不是0.3哦!0.1+0.2≥0.3哦!


切片
用len函数获取长度,cap函数获取占得位置量
make,copy,append是切片的几个特殊函数


^替代了~
++和–不再是表达式操作符(x++是一个语句，不是表达式；*p++是(*p)++，而不是*(p++))
&^是新操作符，在常量表达式中很有用
<<和>>等需要一个无符号的移位计数。


数值转型
将一个数值从一个类型转换为另一个类型称为一次转型，其语法形式有点类似函数调用：

uint8(intVar)   //截断到相应的大小
int(float64Var) //片段截断
float64(intVar) //转为float64

一些涉及string类型的转型：

string(0×1234)          // == "\u1234"
string(sliceOfBytes)    // bytes -> bytes
string(sliceOfInts)     // ints -> Unicode/UTF-8
[]byte("abc")           // bytes -> bytes
[]int("中文")          // Unicode/UTF-8 -> ints


New
内置函数new用于分配内存。其语法类似一个函数调用，以类型作为参数，与C++中的new类似。返回一个指向已分配对象的指针。
var p *Point = new(Point)
v := new(int)   // v的类型为*int


a, b = b, a  //交互a,b的值


可以指定一个label并影响外层结构：
Loop: for i := 0; i < 10; i++ {
    switch f(i) {
        case 0, 1, 2: break Loop
    }
    g(i)
}
是的，那是一个goto。


初始化
0值取决于类型：数值是0；布尔是false；空字符串是""；指针，map、切片、channel是nil；结构体是0等。


Defer
在关闭文件描述符、解互斥锁等场合十分有用。


和在C中一样，函数不能在函数内部声明。



闭包的价值在于可以作为函数对象 或者匿名函数
支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中、作为参数传递给其他函数，最重要的是能够被函数动态地创建和返回。

若在一个集合上进行某种运算，其运算结果仍为集合中的元素，则称该集合为此运算上的闭包。


定义别名
import myFmt "fmt" //使用名字myFmt


在一个包中，所有全局变量、函数、类型以及常量对这个包的所有代码可见。


初始化全局变量：
1) 带有初始化语句的全局声明
2) 在init函数内部
包依赖可以保证正确的执行顺序。
初始化总是单线程的。


测试
要测试一个包，可在这个包内编写一组Go源文件；给这些文件命名为*_test.go。
在这些文件内，名字以Test[^a-z]开头的全局函数会被测试工具gotest自动执行，这些函数应使用下面函数签名：
func TestXxx(t *testing.T)
testing包提供日志、benchmarking、错误报告等支持。

测试代码与被测代码在同一个包中；测试代码要导入testing包；测试 函数要以Test作为前缀，并且测试函数的函数签名必须是这样的：func TestXXX(t *testing.T)。

语言自带对测试的支持的好处是一致性，避免了大家使用不同的测试框架而给阅读、交流和维护带来的不便。


命令行或web工具可以将注释提取出来。
链接：http://golang.org/pkg/
命令：
    % godoc fmt
    % godoc fmt Printf


package是个逻辑概念


查看文档
Go的全量文档几乎与Go安装包一起发布。安装Go后，执行godoc –http=:端口号即可启动doc server。打开浏览器，输入http://localhost:端口号即可以看到几乎与Go官方站完全相同的文档页面。


Go中的数组是值，而非C语言中的隐式指针。


var slice = []int{1,2,3,4,5}
上面代码创建了一个长度为5的数组并创建一个切片用于引用这个数组。

为何用make而不是用new？因为我们需要创建切片，而不仅仅是为了分配内存。注意make([]int, 10)返回[]int，而new([]int)返回*[]int。

使用make创建切片、map以及channel。


使用make分配一个切片，并指定其长度和容量。
var sl = make([]int, 0, 100) // 长度 0, 容量 100

切片是引用

拆分一个Buffer：
  header, data := buf[:n], buf[n:]


var m map[string]float64
声明了一个map，索引key的类型为string，值类型为float64。

三种方式：
1) 字面值：逗号分隔的key:value对列表
  m = map[string]float64{"1":1, "pi":3.1415}

2) 创建
  m = make(map[string]float64)

3) 赋值
  var m1 map[string]float64
  m1 = m

设置一个元素的值
m["2"] = 2

测试存在性
要测试一个map中是否存在某个key，我们可以使用一个多项赋值的"comma, om"形式：
m = map[string]float64{"1":1, "pi":3.1415}
var value float64
var present bool
value, present = m[x]
或者按惯例：
value, ok := m[x] // "comma ok" 形式
如果map中存在x这个key，布尔变量会被设置为true；value会被赋值为map中key对应的值。相反，布尔变量会被设置为false，value被设置为相应值类型的零值。

删除
delete(m, x)。


struct是值类型


一个匿名结构体字段
type A struct {
    ax, ay int
}
 
type B struct {
    A
    bx, by float64
}
它们看起来就像里层的结构体简单插入或“嵌入”到外层结构体似的。

冲突和遮蔽
如果有两个字段具有相同的名字(可能是一个继承类型的名字)，代码将遵循下面规则：
 
1) 外层的名字遮蔽内层的名字。这提供了一个重写字段/方法的方式。
2) 如果在同一层次上出现了相同的名字，如果名字被使用，那么将是一个错误。(如果没有使用，不会出现错误)
二义性是没有规则能解决的，必须被修正。



方法(method)

基于结构体的方法
Go没有类(class)，不过你可以为任何类型附上方法。没错，(几乎是)任何类型。方法声明为一个带有显式接收者的函数，其声明独立于类型的声明。下面是一个明显的例子：
type Point struct { x, y float64 } // A method on *Point 
 
func (p *Point) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y)
}

基于结构体值的方法
一个不需要指针作为接收者的方法：
 
type Point3 struct { x, y, z float64 } 
 
// A method on Point3
func (p Point3) Abs() float64 {
    return math.Sqrt(p.x*p.x + p.y*p.y + p.z*p.z)
}
 
这样的代价有些大，因为Point3类型将以值的方式传入到方法中，但在Go中这是合法的。

调用一个方法

p := &Point{ 3, 4 }
fmt.Print(p.Abs()) // will print 5


一个非结构体的例子：
 
type IntVector []int
func (v IntVector) Sum() (s int) {
    for _, x := range v { // blank identifier!
        s += x
    }
    return
}
fmt.Println(IntVector{1, 2, 3}.Sum())


方法的基本规则
方法附属于一个具名类型，比如Foo，并且是静态绑定的。

方法中接收者的类型可以是*Foo也可以是Foo。你可以有一些Foo方法，也可以有一些*Foo方法。

Foo本身不能是一个指针类型，即便方法可以使用*Foo类型的接收者。
 
类型Foo必须与其全部方法定义在一个包中。


接口
一个接口是一组方法的集合。
由一个具体类型，如一个结构体实现的方法形成了那个类型的接口。


godoc工具
godoc -http=:8000
http://localhost:8000


构建一个Go程序需要两步：编译和链接
gc编译器
gccgo编译器


容器(container)& 空接口

类型断言

接口到接口的转换

Go提供了一个反射(reflect)包，以支持你通过值探索其类型相关信息。太错综复杂，在这里说不方便。



可变参数函数


并发与通信：Goroutines

对于"并发运行的事物"已经有了好多术语 – 进程、线程、协程(coroutine)、POSIX线程、NPTL线程、轻量级进程…，但这些事物都或多或少有不同。并且Go中的并发与哪种都不甚相同。

一个Goroutine是一个与其他goroutines运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。

它与线程、协程、进程等不同。它是一个goroutine。

goroutines可以并行地在不同CPU上执行，共享内存。
你无需担心栈大小。


通信操作符：<-

var c = make(chan int)

c := make(chan int)
c <- 1 // 向c发送1

v = <-c // 从c中接收数据，赋值给v
<-c // 接收数据，丢弃
i := <-c // 接收值，用于初始化i


默认情况下，通信是同步的。(我们后续将讨论异步通信)。这意味着：
1) A在一个channel上的发送操作会阻塞，直到该channel上有一个接收者就绪。
2) 在一个channel上到的接收操作会阻塞，直到该channel上有一个发送者就绪。
因此通信是同步的一种形式：两个通过channel交换数据的goroutine在通信的时刻同步。


一个channel类型可以被指定为只发或只收：
var recvOnly <-chan int
var sendOnly chan<- int


同步的Channel是非缓冲的。发送动作不会完成，直到一个接收者接收这个值。


time.Sleep(60*1e9)
60秒后


异步的Channel
通过告知make缓冲中元素的数量，我们可以创建一个带缓冲的、异步的channel。

缓冲的大小甚至其自身都不是channel类型的一部分，只是值的一部分。


Select
select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是send要么是receive。

ci, cs := make(chan int), make(chan string)
select {
    case v := <-ci:
        fmt.Printf("received %d from ci\n", v)
    case v := <-cs:
        fmt.Printf("received %s from cs\n", v)
}
Select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。

- 每个case都必须是一个通信(可能是:=)
- 所有channel表达式都会被求值
- 所有被发送的表达式都会被求值
- 如果任意某个通信可以进行，它就执行；其他被忽略。
- 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。
- 否则：
    – 如果有default子句，则执行该语句。
    – 如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。


超时
一个通信可以在一个给定的时间内成功完成么？time包包含了after函数：
func After(ns int64) <-chan int64
在指定时间段之后，它向返回的channel中传递一个值(当前时间)。
在select中使用它以实现超时：
select {
case v := <-ch:
    fmt.Println("received", v)
case <-time.After(30*1e9):
    fmt.Println("timed out after 30 seconds")
}


多路复用(multiplexing)

多路复用服务器

启动服务器

客户端


不要通过共享内存通信，相反，通过通信共享内存。



结构体 struct
定义格式：
type 结构体名称 struct {
    属性1    类型
    属性2    类型
    ...
}
结构体的初始化可以使用new关键词和var关键词，不同的是如果使用new，则返回类型是一个指针，使用var，则是结构体自身。
var user User
user.name = "tom"
user.age = 20
简洁的写法：
user := User{"tom", 20} //按顺序给属性赋值
user := User{age: 20, name: "tom"} //指明属性赋值

切片也可以用于字符串：
str := "Anny is a beautiful girl."
fmt.Print(str[0:6]) //输出Anny i


使用字典时，还能动态添加字典元素，也很方便。
ages := map[string] int {
    "tom": 21,
    "anny": 18,
}
ages["jack"] = 20


如果没有使用包内的资源而导入这个包，这在Go语言是不允许的，系统会报出错误信息。


保留字：
break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var


单引号的’a'表示字符，双引号的”a”表示字符串。

在Go语言里 ’1′，”1″，1是不一样的值，这个和C语言是一样的。


Go语言没有类的概念，没有构造、析构函数，更没有继承。只有结构体和接口。


Go语言中的并发是基于函数的。使用 go function() 即可使此函数在新的线程中运行，父线程将继续运行，不会等待函数结束。


new 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，它只是将内存清零，而不是初始化内存。new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。用Go的术语来说，就是它返回了一个指向新分配的类型为T的零值的指针。

make(T, args)函数的目的与new(T)不同。它仅用于创建切片、map和chan（消息管道），并返回类型T（不是*T）的一个被初始化了的（不是零）实例。这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为nil。对于切片、映射和信道，make初始化了其内部的数据结构并准备了将要使用的值。


函数闭包

nextNum这个函数返回了一个匿名函数，这个匿名函数记住了nextNum中i+j的值，并改变了i,j的值，于是形成了一个闭包的用法
func nextNum() func() int {
    i,j := 1,1
    return func() int {
        var tmp = i+j
        i, j = j, tmp
        return tmp
    }
}
//main函数中是对nextNum的调用，其主要是打出下一个斐波拉契数
func main(){
    nextNumFunc := nextNum()
    for i:=0; i<10; i++ {
        fmt.Println(nextNumFunc())
    }
}


函数的递归
和c基本是一样的
func fact(n int) int {
    if n == 0 {
        return 1
    }
    return n * fact(n-1)
}
func main() {
    fmt.Println(fact(7))
}


接口和多态
接口意味着多态



这个函数将返回整数除法的两个部分：
func divide(a, b int) (int, int) {
  quotient := a / b
  remainder := a % b
  return quotient, remainder
}


多返回值的出现促进了"comma-ok"的模式。
if result, ok := moreMagic(); ok {
  /* Do something with result */
}



Go语言还提供了Panic/Recover机制

对于不可恢复的错误，Go提供了一个内建的panic函数，它将创建一个运行时错误并使程序停止（相当暴力）。该函数接收一个任意类型（往往是字符串）作为程序死亡时要打印的东西。当编译器在函数的结尾处检查到一个panic时，就会停止进行常规的return语句检查。
下面的仅仅是一个示例。实际的库函数应避免panic。如果问题可以容忍，最好是让事情继续下去而不是终止整个程序。
var user = os.Getenv("USER")
func init() {
  if user == "" {
    panic("no value for $USER")
  }
}
当panic被调用时，它将立即停止当前函数的执行并开始逐级解开函数堆栈，同时运行所有被defer的函数。如果这种解开达到堆栈的顶端，程序就 死亡了。但是，也可以使用内建的recover函数来重新获得Go程的控制权并恢复正常的执行。 对recover的调用会通知解开堆栈并返回传递到panic的参量。由于仅在解开期间运行的代码处在被defer的函数之内，recover仅在被延期 的函数内部才是有用的。
你可以简单地理解为recover就是用来捕捉Painc的，防止程序一下子就挂掉了。



在Go语言中，错误处理非常重要。语言的设计和规范鼓励开发人员显式地检查错误（与其他语言抛出异常然后catch住是不同的）。这种机制某种程度上使得Go语言的代码冗长重复，但是幸运的是你可以利用一些技巧来把冗长的代码最小化。
Yuval表示这点他无法忍受，每一次函数的调用都需要if语句来判断是否出现错误，他引用了一段官方的所谓最小化代码量的错误处理示例：
if err := datastore.Get(c, key, record); err != nil {
  return &appError{err, "Record not found", 404}
}
if err := viewTemplate.Execute(w, record); err != nil {
  return &appError{err, "Can't display record", 500}
}
Yuval说，这就是在Go语言中调用函数的正确处理方式，甚至连Println的调用都要这样做。如果不这么做会怎样呢？Go语言并没有坚持要采 用这种冗长的错误机制。它也允许忽略这些函数调用错误。但是这样做很危险。在下面的例子中，如果第一个Get函数错误，那么程序继续调用第二个函数！这是 非常恐怖的事情。
func main() {
    http.Get("http://www.nuke.gov/seal_presidential_bunker")
    http.Get("http://www.nuke.gov/trigger_doomsday_device")
}
理论上，我们要求开发人员决不能忽略返回的错误。而实际上，只有在一些关键性的错误上面处理才是必要的。

关于panic/recover机制，Yuval认为也不够出色，因为连Go的标准库都不怎么用这种机制：为什么索引溢出的数组要比错误格式的字符 串或者失败的网络连接更需要panic呢？Go语言希望能够完全避免异常，但实际上不能，总有一些异常会在某处发生，让开发人员在错误出现时感到困惑。

























·go语言教程

go语言教程 —— 易百
http://www.yiibai.com/go/go_start.html


Effective Go

《Go语言三日教程》

对于"if"等 后面有大括弧的语句，需要将左大括弧放在"if"语句的同一行，如果不这样的话可能出现编译错误。 Go语言强制使用将开始大括弧放在同一行末尾的编码风格。

Go是一个编译型的语言。目前有两种编译器，其中"Gccgo"采用GCC作为编译后端。另外还有 根据处理器架构命名的编译器：针对64位x86结构为"6g"，针对32位x86结构的为"8g"等等。 这些go专用的编译器编译很快，但是产生的目标代码效率比gccgo稍差一点。目前（2009年底）， go专用的编译器的运行时系统比"gccgo"要相对健壮一点。

通过"os.Stdout"，我们可以用包中的"WriteString?"方法来输出字符串。

flag.Parse()
"flag"包会解析命令行参数，并将不是flag选项的参数保存到一个列表中。可以通过flag的参数列表 访问普通的命令行参数。

如果想返回一个出错信息，可用系统调用强制退出：
os.Exit(1)

"os"包还包含了其它的许多启动相关的功能，例如"os.Args"是"flag"包的一部分（用来获取命令行输入）。

即使"int"和"int32"占有同样的内存大小，但并不是同一种数据类型。不过 "byte"和"uint8"对应是相同的数据类型，它们是字符串中字符类型。

go中的字符串是一个内建数据类型。字符串虽然是字符序列，但并不是一个字符数组。
可以创建新的 字符串，但是不能改变字符串。

不同于C语言的是："int"类型数组 "arrayOfInt"并不能转化为"int"指针。因为，在Go语言中数组是一个值对象，它在内部保存"int"指针。

如果多个Slices引用同一个数组，则可以共享数组的空间。但是不同数组之间是无法共享内存空间的。

在Go语言中Slices比数组使用的更为普遍，因为它更有弹性，引用的语法也使得它效率很高。 但是，Slices缺少对内存的绝对控制比数组要差一些。例如你只是想要一个可以存放100个元素 的空间，那么你就可以选择数组了。

创建数组：[3]int{1,2,3}

当需要传递一个数组给函数时，你应该将函数的参数定义为一个Slice。这样，在调用函数的时候， 数组将被自动转换为slice传入。

将数组转为slice类型
[3]int{1,2,3}[:]

如果你创建一个初始化的数组，你可以让编译器自动计算数组的元素数目，只要在数组大小中填写"..."就 可以了：
s := sum([...]int{1,2,3}[:])

实际编码中，如果不关心内存的具体细节，可以用slice类型（省略数组的大小）来代替数组地址为函数参数：
s := sum([]int{1,2,3});

map类型
m := map[string]int{"one":1 , "two":2}

"len()"函数，可以获取map中元素的数目
"len()"函数 还可以用在strings, arrays, slices, maps, 和 channels 中。

"range"语法可以用到strings, arrays, slices, maps, 和 channels 中， 它可以用于"for"循环的迭代。
for i := 0; i < len(a); i++ { ... }
用"range"语法可以写成：
for i, v := range a { ... }
这里的"i"对应元素的索引，"v"对应元素的值。

在Go语言中，大部分的类型都是值变量。
例如int或struct(结构体)或array(数组)类型变量， 赋值的时候都是复制整个元素。

如果需要为一个值类型的变量分配空间，可以用new()：
type T struct { a, b int }
var t *T = new(T);
或者更简洁的写法：
t := new(T);

还有另外一些类型，如：maps, slices 和 channels(见下面)是引用语意（reference semantics）。 如果你改变一个slice 或 map内的元素，那么其他引用了相同slice 或 map的变量也能看到这个改变。 对于这三类引用类型的变量，需要用另一个内建的make()分配并初始化空间：
m := make(map[string]int);
上面的代码定义一个新的map并分配了存储空间。如果只是定一个map而不想分配空间的话，可以这样：
var m map[string]int;
它创建了一个nil(空的)引用并且没有分配存储空间。如果你想用这个map, 你必须使用make来 分配并初始化内存空间或者指向一个已经有存储空间的map。

注意: new(T) 返回的类型是 *T , 而 make(T) 返回的是引用语意的 T 。如果你(错误的)使用 new()` 分配了一个引用对象，你将会得到一个指向 nil 引用的指针。这个相当于声明了一个未初始化引用变量并取得 它的地址。

常量只有 在最终被赋值给一个变量的时候才可以会出现溢出的情况：
const hardEight = (1 << 100) >> 97  // legal，合法

（强制？）转换只适用于几种简单的情况：转换整数(int)到去其他的精度和大小，整数(int)与 浮点数(float)的转换, 还有其他一些简单情形。在Go语言中，系统不会对两种不同类型变量作 任何隐式的类型转换。此外，由常数初始化的变量需要指定确定的类型和大小。

包os封装了不同操作系统底层的实现，例如将文件抽象成相同的类型。
底层的syscall包，它提供一些底层的系统调用(system's calls)。

在GO中访问规则的处理 是非常简单的：如果顶极类型名字首字母(包括：function, method, constant or variable, or of a structure field or method)是大写，那么引用了这个包(package)的使用者就可以访问到它。不然 名称和被命名的东西将只能有package内部看到。这是一个要严格遵循的规则，因为这个访问规则是由 编译器(compiler)强制规范的。在GO中，一组公开可见的名称是"exported"。

在Open函数中，我们用os.Error函数将Unix的整数错误代码转换为go语言的错误类型。
err = os.Errno(e)

类型的方法(methods)也不是定义在struct内部——struct结构 只声明数据成员(data members)。
事实上，我们可以给任意数据类型定义方法，例如：整数(integer)，数组(array) 等。


import "./包名"

"switch"语句中的每个"分支"(case)都 默认隐藏了"break".


接口(interfaces)是Go的一个特性，一个接口是由类型实现的，接口就是声明该类型的所有方法。 也就是说一个类型可以实现多个不同的接口, 没有任何类型的限制，

空接口(empty interface)
type Empty interface {}
任何类型都默认实现了空接口，我们可以用空接口来保存任意类型。


接口(interfaces)提供了一个简单形式的多态(polymorphism). 他们把对象的定义和 如何实现的分开处理，允许相同的接口可以有不能的实现方法。

用"%d"表示要输出一个整数
如果是使用"Print"或"Println"函数的话，甚至不需要格式化字符串。这些函数会针对数据类型 自动作转换。"Print"函数默认将每个参数以"%v"格式输出，"Println"函数则是在"Print"函数 的输出基础上增加一个换行。

这里用到了类型断言("v.(Stringer)")，用来判断变量"v"是否可以满足"Stringer"接口。


管道可以用于连接两个并行的处理单。在Go语言中， 管道由运行时库管理，可以用"make"来创建新的管道。

二元操作符"<-"， 它用于向管道发送数据。当管道没有接受者的时候 会阻塞，直到有接收者从管道接受数据为止。

Go语言有自己的并发 程序设计模型，这个和传统的进程/线程/轻量线程类似。为了区别，我们把Go语言 中的并行程序称为goroutines。如果一个函数要以goroutines方式并行执行， 只要用"go"关键字作为函数调用的前缀即可。goroutines和它的启动线程并行执行， 但是共享一个地址空间。


管道Multiplexing
我们可以很容易实现一个支持多路客户端的服务器程序。采用的技巧是将每个客户端私有的通信管道 作为消息的一部分发送给服务器，然后服务器通过这些管道和客户端独立通信。
 ****
http://www.yiibai.com/go/go_multiplexing.html


itoa使用
const(
a = iota
b
)
iota是go的常量赋值自增量，上面代码将a设置为0，b设置为1

len(a)

想要扩展slice，append和copy两个内建函数。
区别内建函数和第三方库函数的区别是，内建函数是小写字母开头，如copy()，第三方库函数是首字母大写，如fmt.Print()

map结构是一个hash映射

可以使用_来扔掉不需要的返回值

Go里面switch默认相当于每个case后面带有break，匹配成功后不会自动向下尝试，而是跳出整个switch了，但是可以使用fallthrough使其这样做。

用range遍历
	i := []int{1,2,3,4,5,6,7,8,9,0};
	for _,v := range i {
		fmt.Println(v);
	}


多通道复用(multiway communications multiplexer)的select


Go语言函数
http://www.yiibai.com/go/go_function.html


内部函数 make(T, args) 的服务目的和 new(T) 不同。它只生成切片，映射和信道，并返回一个初始化的（不是零）的，type T的，不是 *T 的值。


切片是一个三项的描述符，包含数据指针（数组内），长度，和容量；在这些项初始化前，切片为 nil 。

对于切片、映射和信道，make 初始化内部数据结构，并准备要用的值。

make([]int, 10, 100)
分配一个 100 个整数的数组，然后生成一个切片结构，长度为10，容量是100的指向此数组的首10项。

记住 make() 只用于映射、切片和信道，不返回指针。要明确的得到指针用 new() 分配。

切片是引用类型，即如果赋值切片给另一个切片，它们都指向同一底层数组。
类似于传递一个底层数组的指针。
切片的长度决定了可读数据的上限。

只要还在底层数组的限制内，切片的长度可以改变，只需赋值自己。

切片的容量，可用内部函数 cap 取得，给出此切片可用的最大长度。

        []int{1, 2, 3},               //slice 切片
        []int{1, 2, 3}[:],            //切片再切还是切片
        [3]int{1, 2, 3},              //array 数组，确定数组长度
        []int{1, 2, 3}[:],            //数组切一下，切出个 slice切片
        [...]int{1, 2, 3},            //array 数组，由编译器自动计算数组长度。


最标准的slice切片定义方法：
v := make([]int, 3, 10);     //一个slice，有三个参数 类型、slice长度、slice底层的array长度，即slice的最大容量。

如果要扩展 slice的大小使用 append添加元素。否则使用 v[4] = 10 这样增加元素的时候会报 索引出错。


var v1 int = 10
var v2 = 10
v3 := 10
以上三种用法完全一样
3种用法完全一样不准确，第三种用法只能在函数内部使用
变量初始化的效果一样，但作为全局变量只能用var声明。

Maps 字典、映射
结构，数组和切片不可用作映射键

试图获取不存在的键的映射值返回对应条目类型的零值。

有时你需区分不在键和零值。 是没有 “UTC” 的条目，还是因为其值为零？你可以用多值赋值的形式加以区分。

  var seconds int
  var ok bool
  seconds, ok = timeZone[tz]
此习语称为“逗号ok”。此例中，如果 tz 存在，seconds 相应赋值，ok为真；否则，seconds 为0，ok为假。

下面的函数加上了出错报告：
  func offset(tz string) int {
      if seconds, ok := timeZone[tz]; ok {
          return seconds
      }
      log.Stderr("unknown time zone", tz)
      return 0
  }

要检查映射的存在，又不想管实际值，你可以用空白标识，即下划线（ _ ）。空白标识可以赋值或声明为任意类型的任意值，会被无害的丢弃。
  _, present := timeZone[tz]


fmt.Printf，fmt.Fprintf， fmt.Sprintf 等

Print 和 Println。 它们不需排版字串，而是用每个参量默认的格式。Println 版本还会在参量间加入空格和输出新行，而 Print 版本只当操作数的两边都不是字串时才添加空格。

fmt.Fprint 和伙伴们的第一个参量可以是任何实现 io.Writer 界面的物件。变量 os.Stdout 和 os.Stderr 是熟悉的实例。

fmt.Printf
此格式可打印任意值，包括数组，结构和映射。
当然，映射的键会以任意顺序输出。打印结构时，改进的格式 %+v 用结构的域名注释，对任意值格式 %#v 打印出完整的 Go 句法。

引号括起的字串也可以 %q 用在 string 或 []byte 类型的值上，对应的格式 %#q 如果可能则使用反引号。还有，%x 可用于字串、字节数组和整型，得到长的十六进制串，有空格的格式（% x）会在字节间加空格。

另一好用的格式是 %T，打印某值的类型。

append
x := []int{1,2,3}
  x = append(x, 4, 5, 6)
  fmt.Println(x)

给切片添加切片
使用 ... 
  x := []int{1,2,3}
  y := []int{4,5,6}
  x = append(x, y...)
  fmt.Println(x)
没有 ... 将不能编译，因为类型错误； y 不是 int 类型。


init函数

每个源文件可以定义自身的 init() 函数
init() 发生在包里所有变量初始化之后，而其又发生在所有的包全部导入之后。
除了初始化不能表示为声明外，init() 函数常用来在程序运行前验证或修补其状态。


Generality(泛化)


并发

共享变量


错误处理
一般情况下，错误都实现了os.Error 接口。

 ****
Go语言编写Web程序
http://www.yiibai.com/go/go_web_programe.html



Go语言同步(Synchronization)
http://www.yiibai.com/go/go_Synchronization.html
http://www.yiibai.com/go/go_synchronize_error.html

















·Go语言


安全：类型安全与内存安全。没有继承，无需处理类型的依赖关系，弱化类型的使用；变量默认初始化，简化设计负担。
并发和通信的支持。内建的并发机制使得多线程编程变得非常简单；内建的chan（channel）类型简化了线程间通讯。
完全的内存垃圾回收机制。
高速编译。没有头文件、Makefile等复杂的工程依赖关系，使得编译速度更快，工程更容易组织。



2009年7月份,谷歌曾发布了Simple语言,它是用来开发Android应用的一种BASIC语言.

Go语言是谷歌2009发布的第二款开源编程语言。Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。

,Go是一种系统语言
同时它还是一个真正的编译语言

编译后Go代码的运行速度与C语言非常接近,而且编译速度非常快,就像在使用一个交互式语言.现有编程语言均未专门对多核处理器进行优化.Go就是谷歌工程师为这类程序编写的一种语言.它不是针对编程初学者设计的,但学习使用它也不是非常困难.Go支持面向对象,而且具有真正的封装(closures)和反射 (reflection)等功能.在学习曲线方面,派克认为Go与Java类似,对于Java开发者来说,应该能够轻松学会 Go.之所以将Go作为一个开源项目发布,目的是让开源社区有机会创建更好的工具来使用该语言,例如 Eclipse IDE中的插件.

Go的确可以和Native Client配合使用.他表示,“Go可以让应用完美的运行在浏览器内.”例如,使用Go可以更高效的实现Wave,无论是在前端还是后台.

Go 同时具有两种编译器,一种是建立在GCC基础上的Gccgo,另外一种是分别针对64位x86和32位x86计算机的一套编译器(6g和8g).谷歌目前正在研发其对ARM芯片和Android设备的支持.派克表示,“Android手机存在的问题是,我们一直没有一个数学协处理器.”


Golang有很浓厚的C的遗风，尽量屏蔽C++和Java的影响，比如没有独立的OO体系（并不是说不能OO），一切以struct为中心，没有exceptions(Oh yes!)，仍然有指针，等等。但是，Golang又吸取了很多新语言的精华，并带有自己独特的设计。

Golang被Google用于Youtube的数据库，被越来越多的国外公司(大部分创业公司)用于后端开发，甚至在天朝，也有完全用Golang做服务开发的云应用公司了。

Python目前在很多地方都用C做核心运算

Go可以调用C/C++程序，又提供了太多的便利，速度上稍有牺牲，但并不大。在绝大部分场景下Go能给你带来媲美C的性能，而对于某些确实性能过于关键的场合，也可以通过cgo让Go和C搭配。

现在做好比较好的架构，都把功能部署成服务而非代码，只要服务的协议不变，提供服务的到底是什么语言都无所谓了，

Go比Python方便，Go不用别的什么库就能很好工作了，HTML template这些本来也是自带的，自己的http 服务特性也很强大，加上一两个Gorilla web toolkit里面的东西，session, cookie什么的都有了，源代码也u好读，自定制很方便

我喜欢Golang，但是，让我不爽的是，花括号不能单独一行。。。或许得慢慢习惯这个该死的设计。。
写的时候不用care，最后用gofmt执行一下就完了

Golang 只有 25 个关键字和 47 个操作符号、分隔符号或其他特殊标记。

精巧的类型系统相当容易使用。实用的，具有方法的结构体类型代替了笨重的对象系统。接口的设计是 Golang 中我最喜欢的部分。

PHP 脚本是由 SAPI 组件进行解析执行的，如 Web 服务器模块、PHP-FPM 或者 CLI。部署 PHP 所需要的全部东西就是一个 SAPI 环境。

所有的 Golang 代码会编译和链接为本地码。所以除了编译环境，执行时无需再为其进行任何特别的部署。


有三个步骤需要处理：

下载 Golang 的源代码；
根据《[翻译]Go 环境设置》的提示设置环境变量；
运行源代码 src 目录中的 all.bash。

或者一步到位：使用二进制包进行安装。

一个慢数据源可以阻塞整个页面的处理。消息队列、缓存、代理……系统开始不仅仅是 PHP 这么单纯，还包括了许多服务和系统组件。这时，PHP 只处理很少的业务逻辑，成为真正的模板语言了。


个 go 工具只做一件事情，并且把这件事情做得很好。例如，我们有：

go build – 编译包，
go get – 解析并安装依赖，
go test – 执行测试用例和性能测试，
go install – 安装包，
go doc – 生成文档，
go fmt – 格式化代码，
go run – 构建并执行应用，
go tool – 调用扩展工具，



所有熟悉 Rails 的开发者都会同意，每当你尝试做一些微小的改进，一点点小技巧，一些不遵循规则的东西，它就……

 go 代码树到底是什么？简单说，它就是所有 go 资源、包和命令存放的地方。

所有的代码会放到 src 目录
我所说的所有的代码意味着包含你的应用、包和依赖。pkg 目录包含编译和安装后的包，而 bin 存放命令。

go 工具
http://www.mikespook.com/2012/02/%E7%BF%BB%E8%AF%91go-%E5%B7%A5%E5%85%B7/

Go 指南
http://go-tour-zh.appsp0t.com/#1


channel 
线程、携程、actor、future 和 promise

类型推断。Go 有一个类型推断符号（:=）可以在编译时推导出类型

gc Go compiler and the gccgo compiler


使用 go get 安装 gotour：

    go get code.google.com/p/go-tour/gotour
中文版本：

    go get bitbucket.org/mikespook/go-tour-zh/gotour

包名与导入路径的最后一个目录一致

在 Go 中，首字母大写的名称是被导出的。
Foo 和 FOO 都是被导出的名称。 名称 foo 是不会被导出的。


http://golang.org/

Go project's downloads page
http://code.google.com/p/go/downloads

函数可以没有参数或接受多个参数。
类型在变量名之后

Go 指南
http://go-tour-zh.appsp0t.com/

如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。

在函数中，:= 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。

（:= 结构不能使用在函数外，函数外的每个语法块都必须以关键字开始。）

常量可以是字符、字符串、布尔或数字类型的值。

if 语句可以在条件之前执行一个简单的语句
由这个语句定义的变量的作用域仅在 if 范围之内。
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

Go 有指针，但是没有指针运算。

结构体字段可以通过结构体指针来访问。通过指针间接的访问是透明的。

new 函数

表达式 new(T) 分配了一个零初始化的 T 值，并返回指向它的指针。

var t *T = new(T)
或

t := new(T)

map 的文法，键名是必须的
var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}
如果顶层类型只有类型名的话，可以在文法的元素中省略键名。
var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

修改 map
在 map m 中插入或修改一个元素：m[key] = elem
获得元素：elem = m[key]
删除元素：delete(m, key)
通过双赋值检测某个键存在：elem, ok = m[key]
如果 key 在 m 中， ok 是 true。 否则，ok 是 false 并且 elem 是 map 的元素类型的零值。
同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。

p := []int{2, 3, 5, 7, 11, 13}
fmt.Println("p[1:4] ==", p[1:4])

函数也是值。
函数是完全闭包的。

Go playground 中的时间总是从 2009-11-10 23:00:00 UTC 开始


建议界面上不要走MFC的思路，即使VB6的界面方式也比MFC要好得多。可以参考QT的界面思路，或HTML的界面思路，或者WPF（XAML）的界面思路。
说起QT啊，我不喜欢它的做法，相比之下我更喜欢wxwidget的方式。
从长远来说，HTML、XAML、HTML5应该是今后界面的发展方向

Axure原型工具就是通过使用各种工具在画布上布局，然后可以生成html代码








·练习题


1 创建一个基于for的简单的循环。使其循环10次，并且使用fmt包打印出计数器的值。

2 用goto修改1的循环，不可使用for

3 再次改写1的循环，使其遍历一个array，并将array打印到屏幕上

4 编写一个逆转字符串的程序，例如："foobar"打印成为"raboof";

5 函数练习，找出最大值

6 函数练习，返回两个值，a+b,a*b

7 实现WordCount函数。此函数输入一句英文语句，并返回一个map类型，存储每个单词对应的重复次数。主函数以及写好，包含一个wc.Test函数，用于测试WordCount函数的正确性。
提示：strings.Fields可能会很有帮助。


8 Go的一个性能瓶颈。Go语言字符串转换对象(strconv)性能超烂
http://community.itbbs.cn/thread/21483/


9 猜数游戏

二分查找

100个数要猜7次，因为2⁷= 128。而100万个数，猜猜看要猜多少次？20次就可以了。

二分查找很快，但一次就写出正确的二分查找程序却是出了名的难。建议读者自己动手试着重写一遍。这也是C和其他语言都提供二分查找库函数的一个原因。Go可以使用sort包的Search函数：












































·Go语言文件操作
http://blog.tcreator.com/?p=913


建立文件函数：

func Create(name string) (file *File, err Error)

func NewFile(fd int, name string) *File

打开文件函数：

func Open(name string) (file *File, err Error)

func OpenFile(name string, flag int, perm uint32) (file *File, err Error)

写文件函数：

func (file *File) Write(b []byte) (n int, err Error)

func (file *File) WriteAt(b []byte, off int64) (n int, err Error)

func (file *File) WriteString(s string) (ret int, err Error)




-------------------------------
写文件示例代码：
package main
import (
        "os"
        "fmt"
)
func main() {
        userFile := "test.txt"
        fout,err := os.Create(userFile)
        defer fout.Close()
        if err != nil {
                fmt.Println(userFile,err)
                return
        }
        for i:= 0;i<10;i++ {
                fout.WriteString("Just a test!\r\n")
                fout.Write([]byte("Just a test!\r\n"))
        }
}
-------------------------------
	//结果写文件
	fileName := "src.txt"
	f, err := os.Create(fileName)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer f.Close()

	f.WriteString(v) //结果写文件

-------------------------------


读文件函数：

func (file *File) Read(b []byte) (n int, err Error)

func (file *File) ReadAt(b []byte, off int64) (n int, err Error)

-------------------------------
读文件示例代码：
package main
import (
        "os"
        "fmt"
)
func main() {
        userFile := "test.txt"
        fin,err := os.Open(userFile)
        defer fin.Close()
        if err != nil {
                fmt.Println(userFile,err)
                return
        }
        buf := make([]byte, 1024)
        for{
                n, _ := fin.Read(buf)
                if0 == n { break }
                os.Stdout.Write(buf[:n])
        }
}
-------------------------------

删除文件
func Remove(name string) Error



























·问题、链接、代码



使用 Go 语言和 HTML5 WebSocket 构建一个 Web 聊天室
http://www.oschina.net/question/12_63247



简单客户端服务器模型（C++、python和go语言示例）
http://blog.tcreator.com/?p=905





集
http://community.itbbs.cn/forum/63/





方法和接口
http://go-tour-zh.appsp0t.com/#49

Web 服务器
http://go-tour-zh.appsp0t.com/#56



练习：Web 爬虫
http://go-tour-zh.appsp0t.com/#70




 ****
Go语言并发之美
http://www.open-open.com/lib/view/open1360024984221.html
http://www.cnblogs.com/yuxingfirst/archive/2012/11/28/2792366.html
多路复用技术


用 Google App Engine 开发 Go 语言应用的简明教程
http://proppy-go-ae.appspot.com/
http://progginator.lidian.info/#1

从零到 Go：24 小时内登上 Google 主页的 Go 语言应用“火鸡”doodle 开发纪实
http://www.open-open.com/news/view/1c0a316


App Engine 的 Hello World Go 示例https://developers.google.com/appengine/docs/go/gettingstarted/helloworld?hl=zh-CN
https://developers.google.com/readme/?hl=zh-CN









问题集
http://www.oschina.net/p/go



 ****
Go语言编写Web程序
http://www.yiibai.com/go/go_web_programe.html

Google app engine Go语言开发:数据存储
http://www.usr.cc/thread-52656-1-1.html

用Golang Go语言写个http代理服务器
http://www.usr.cc/thread-52554-1-1.html



迷你 NoSQL 服务器：Tinydb
http://www.open-open.com/lib/view/open1354868229779.html


go-note：Go语言写的日记簿
http://www.open-open.com/lib/view/open1355748991541.html
gnote是一款基于golang语言编写的记事本，不依赖于数据库，gnote直接采用系统文件系统进行日志存储，因此日记库支持一键打包功能。


Go语言写的随机森林库：RF.go
http://www.open-open.com/lib/view/open1353035738832.html


Go ioutil包翻译
http://www.open-open.com/lib/view/open1352160969485.html
ioutil包含有一些公用的I/O工具函数。 

Go语言实现的分散式散列表：Pastry
http://www.open-open.com/lib/view/open1350778150258.html


Go语言的Session管理器： SessionManager
http://www.open-open.com/lib/view/open1348630062775.html















Go语言实现的 LevelDB key/value 数据库 - goleveldb
http://www.open-open.com/lib/view/open1359620402164.html
Go 语言版的 OpenCV 封装 - GoOpenCV
http://www.open-open.com/lib/view/open1341845443166.html



Go 语言开发的宠物小精灵游戏 - Pokemon Universe
http://www.open-open.com/lib/view/open1341845526354.html

搜索引擎Sphinx的Go开发包 GoSphinx
http://www.open-open.com/lib/view/open1341878672072.html






Golang Go语言实现Virtualhost虚拟主机效果
http://www.usr.cc/thread-52555-1-1.html

Google app engine Go语言开发:使用“用户服务”
http://www.usr.cc/thread-52654-1-1.html

Google app engine Go语言开发:处理表单
http://www.usr.cc/thread-52655-1-1.html

Google app engine Go语言开发:数据存储
http://www.usr.cc/thread-52656-1-1.html




http://golang.org:                 官网
golang-nuts@golang.org:    用户讨论组
golang-dev@golang.org:     开发者讨论组


一些被墙的
http://bbs.golang-china.org/
http://golang.org/doc/docs.html
http://golang.org/doc/go_tutorial.html
http://golang.org/doc/codelab/wiki/
http://golang.org/doc/effective_go.html
http://go-tour-zh.appspot.com/






Go's Declaration Syntax
http://golang.org/doc/articles/gos_declaration_syntax.html

Google App Engine SDK for Go
https://developers.google.com/appengine/downloads?hl=zh-CN#Google_App_Engine_SDK_for_Go

How to Write Go Code
http://golang.org/doc/code.html

Directory /src/pkg
http://golang.org/pkg/

The Go Programming Language Specification
http://golang.org/ref/spec














在 Go 应用中使用简明架构
http://www.mikespook.com/2012/09/%E7%BF%BB%E8%AF%91%E5%9C%A8-go-%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E6%9E%B6%E6%9E%841/
通过消息传递来组织是个途径。这是 OO 编程的基础，但是大多数编程语言做得很差。

Golang Go语言 container/ring闭环数据结构的使用方法
http://www.usr.cc/thread-52549-1-1.html


Golang Go语言结构体中匿名字段暴露方法的优先级
http://www.usr.cc/thread-52551-1-1.html


Go使用C的库非常简单，通过cgo这个工具基本上可以说是无缝集成了。
http://www.cnblogs.com/AllenDang/archive/2012/02/21/2361197.html






------------------------------- 已浏览
golang-china
Go 语言中文翻译项目
http://code.google.com/p/golang-china/
-------------------------------



* go get出现bzr 出错

需要安装 bzr 即 bazaar
http://wiki.bazaar.canonical.com/zh/Bzr%E4%BB%8B%E7%BB%8D





* Windows下CMD执行Go中文乱码问题解决方法

因为Go的编码时UTF-8，而cmd的活动页是cp936（GBK），因而乱码。

如何在DOS窗口中显示UTF-8字符

在中文Windows系统中，如果一个文本文件是UTF-8编码的，那么在CMD.exe命令行窗口（所谓的DOS窗口）中不能正确显示文件中的内容。在默认情况下，命令行窗口中使用的代码页是中文或者美国的，即编码是中文字符集或者西文字符集。
如果想正确显示UTF-8字符，可以按照以下步骤操作：
1、打开CMD.exe命令行窗口
2、通过 chcp命令改变代码页，UTF-8的代码页为65001
chcp 65001
执行该操作后，代码页就被变成UTF-8了。但是，在窗口中仍旧不能正确显示UTF-8字符。
3、修改窗口属性，改变字体
在命令行标题栏上点击右键，选择"属性"->"字体"，将字体修改为True Type字体"Lucida Console"，然后点击确定将属性应用到当前窗口。
这时使用type命令就可以显示UTF-8文本文件的内容了：
type filename.txt
4、通过以上操作并不能完全解决问题，因为显示出来的内容有可能不完全。可以先最小化，然后最大化命令行窗口，文件的内容就完整的显示出来了。

原文：http://blog.sina.com.cn/s/blog_794b1d96010136yy.html





* 用Go写Windows桌面应用

用Go写Windows桌面应用 - 使用窗体设计器
http://www.cnblogs.com/AllenDang/archive/2012/02/28/2372526.html

用Go写Windows桌面应用 - 使用资源文件
http://www.cnblogs.com/AllenDang/archive/2012/02/16/2354109.html

用Go写Windows桌面应用 - 使用Form
http://www.cnblogs.com/AllenDang/archive/2012/02/15/2352424.html

使用CGO封装Windows API
http://www.cnblogs.com/AllenDang/archive/2012/02/21/2361197.html





* Golang Go语言中的try … except …统一的异常处理

写python的时候，有时候懒得一个一个错误去分别处理，直接使用一个整体来try catch来捕获所有异常。如：

[code=python]try:
    one()
    two()
    three()
except:
    处理异常[/code]

Go中的实现方式：
[code=java]func main() {
        defer func() {
            if e, ok := recover(); ok {
            println(e.String())  //打印出错误
        }
        }()
        one()
        two()
        three()
        ...
}[/code]




* Golang Go语言限制goroutine数量的方法

package main 

import "time"

func work(ch chan int) {  //工作方法
    //做事
    <- ch  //完事后在 ch里面抽一个数。
} 

func main() {
    ch := make(chan int, 100)  //限制100个goroutine
    for i := 0; ; i++ {
        ch <- 1              //如果当有已经有100个goroutine在工作，那么此事就会堵塞直到有goroutine工作完
        go work(ch)
    }
}


* Golang Go语言 container/ring闭环数据结构的使用方法

//引入包
import "container/ring"
//创建闭环，这里创建10个元素的闭环
r := ring.New(10)
//给闭环中的元素附值
for i := 1; i <= r.Len(); i++ {
    r.Value = i
    r = r.Next()
}
//循环打印闭环元素的值，这里的操作方法很像javascript
r.Do(func(p interface{}){
    println(p)
})
//当前元素就是
// r
//当前元素的值就是
// r.Value       //这里是 1
//取得当前元素之后的第5个元素
r5 := r.Move(5)    //这里是 6
//链接 当前元素r与r5，相当于删除了r跟r5之间的元素，使 r.Next() == r5
rl := r.Link(r5)  //这样 r环里有 1 6 7 8 9 10
                    //rl 环路里有  2 3 4 5 

//把rl环加回到 r环原来的位置
//要确保r的当前位置是 1，rl的当前位置为2
rf := r.Link(rl)
//这样 r就变回了 1 2 3 4 5 6 7 8 9 10
//rf则是 从 rl.Next()开始环，内容则与 r的一样。
//6 7 8 9 10 1 2 3 4 5
另外做过一次 Do()循环操作后 闭环的当前位置不变。


* Golang Go语言发送邮件的方法

传统的思路

[code=java]package main

import (
        "log"
        "smtp"
)

func main() {
        // Set up authentication information.
        auth := smtp.PlainAuth(
                "",
                "user@example.com",
                "password",
                "mail.example.com",
        )
        // Connect to the server, authenticate, set the sender and recipient,
        // and send the email all in one step.
        err := smtp.SendMail(
                "mail.example.com:25",
                auth,
                "sender@example.org",
                []string{"recipient@example.net"},
                []byte("This is the email body."),
        )
        if err != nil {
                log.Fatal(err)
        }
}[/code]

GO语言流式操作方法来发邮件


[code=java]package main

import (
        "log"
        "smtp"
)

func main() {
        // Set up authentication information.
        auth := smtp.PlainAuth(
                "",
                "user@example.com",
                "password",
                "mail.example.com",
        )
        // Connect to the remote SMTP server.
        c, err := smtp.Dial("mail.example.com:25")
        if err != nil {
                log.Fatal(err)
        }
        err = c.Auth(auth)
        if err != nil {
            log.Fatal(err)
        }
        // Set the sender and recipient.
        c.Mail("sender@example.org")
        c.Rcpt("recipient@example.net")
        // Send the email body.
        wc, err := c.Data()
        if err != nil {
                log.Fatal(err)
        }
        defer wc.Close()
        if _, err = wc.Write([]byte("This is the email body.")); err != nil {
                log.Fatal(err)
        }
}[/code]






















*


